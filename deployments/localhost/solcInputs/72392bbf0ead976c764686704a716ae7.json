{
  "language": "Solidity",
  "sources": {
    "contracts/UnRealArt.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/Base64.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC1155.sol\";\n\n// Simple contract for registering series of NFT artworks\n// Contract isn't very flexible on purpose. Trying to keep it as simple as possible, since no audits are done and minimal testing.\ncontract UnRealArtV2 is ERC1155 {\n    using BoringAddress for address;\n    using Base64 for bytes;\n\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\n        return super.supportsInterface(interfaceID) || interfaceID == 0x2a55205a; // EIP-2981 NFT Royalty Standard\n    }\n\n    struct Series {\n        address creator;\n        string author; // Twitter handle or name\n        string name; // Short name of the series\n        string description; // Description of the series, such as inspiration, etc\n        string process; // Describe the tools & prompts used\n        uint256 price; // Price\n        // Each image should be added to IPFS **individually**. This means that anyone owning the\n        // NFT only needs to keep a copy of their picture to proof ownership in the (far) future,\n        // not the entire series as is the case with a lot of PFP NFTs :D\n        string[] artworks; // List of IPFS v0 CIDs of the artworks \"Qm....\"\n    }\n\n    Series[] public series;\n\n    function getSerie(uint256 serie) public view returns (Series memory) {\n        return series[serie];\n    }\n\n    function seriesCount() public view returns (uint256) {\n        return series.length;\n    }\n\n    event LogCreateSeries(uint256 indexed index, address indexed to, uint256 editions);\n    event LogBuy(uint256 indexed serie, uint256 indexed artwork, uint256 price, address indexed gallery);\n\n    function createSeries(\n        string calldata author,\n        string calldata name,\n        string calldata description,\n        string calldata process,\n        uint256 price,\n        string[] calldata imageUrls,\n        address to\n    ) public returns (uint256 index) {\n        // Get the index of the new series in the array\n        index = series.length;\n\n        // Initialize a new series with name and description.\n        // Creator is set to the sender\n        Series memory s;\n        s.creator = to;\n        s.author = author;\n        s.name = name;\n        s.description = description;\n        s.process = process;\n        s.price = price;\n\n        series.push(s);\n\n        for (uint256 i = 0; i < imageUrls.length; i++) {\n            _mint(\n                to,\n                index * uint256(1e6) + series[index].artworks.length,\n                1\n            );\n            series[index].artworks.push(imageUrls[i]);\n        }\n\n        emit LogCreateSeries(index, to, 1);\n    }\n\n    // Reentrancy guard on the buy function\n    bool private buying = false;\n\n    function buy(\n        uint32 serie,\n        uint32 artwork,\n        address gallery\n    ) public payable {\n        require(!buying, \"Not again!\");\n        buying = true;\n        uint256 id = uint256(uint32(serie)) * 1e6 + uint256(uint32(artwork));\n\n        require(balanceOf[series[serie].creator][id] == 1, \"Not for sale\"); // Has to be owned by the creator (series owner), could have been transferred\n        uint256 price = series[serie].price;\n        // Check if enough ETH was sent. Not really needed as we attempt the actual transfer later.\n        require(msg.value >= price, \"Not enough funds sent\");\n        require(msg.sender != series[serie].creator, \"Cannot buy own work\");\n\n        _transferSingle(series[serie].creator, msg.sender, id, 1);\n\n        // Refund any excess ETH by sending any remaining ETH on the contract back.\n        msg.sender.sendNative(address(this).balance - price);\n\n        // The creator gets the remaining 90%\n        series[serie].creator.sendNative((price * 90) / 100);\n\n        // The gallery that sold the artwork gets 10% commission\n        // Sure, the buyer could redirect this back to themselves when they bypass the UI, but like\n        // royalty payments, we rely on some honesty/convenience here. If no gallery is given, the 10%\n        // goes to the platform\n        (gallery != address(0) ? gallery : 0x9e6e344f94305d36eA59912b0911fE2c9149Ed3E).sendNative((price * 10) / 100);\n\n        emit LogBuy(serie, artwork, price, gallery);\n        buying = false;\n    }\n\n    function royaltyInfo(uint256 id, uint256 price) public view returns (address receiver, uint256 royaltyAmount) {\n        return (series[id / 1e6].creator, price / 10);\n    }\n\n    // From OpenZeppelin Math.sol\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    // From OpenZeppelin Strings.sol\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    function uri(uint256 id) external view override returns (string memory) {\n        uint256 serie = id / 1e6;\n        uint256 artwork = id % 1e6;\n\n        // solhint-disable quotes\n        string memory json_part1 = string(abi.encodePacked(\n            '{\"name\":\"',\n            series[serie].name,\n            \" \", toString(artwork + 1),\n            '\",\"description\":\"',\n            series[serie].description,\n            '\",\"image\":\"ipfs://ipfs/',\n            series[serie].artworks[artwork]\n        ));\n\n        string memory json_part2 = string(abi.encodePacked(\n            '\",\"external_url\": \"https://un-real-art.com/#/image/', toString(serie), '/', toString(artwork), \n            '\",\"decimals\":0,\"properties\":{\"author\":\"',\n            series[serie].author,\n            '\",\"process\":\"',\n            series[serie].process,\n            '\"}}'\n        ));\n\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    abi\n                        .encodePacked(json_part1, json_part2)\n                        .encode()\n                )\n            );\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n\nlibrary BoringAddress {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendNative(address to, uint256 amount) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"BoringAddress: transfer failed\");\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n// solhint-disable no-empty-blocks\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n                case 1 {\n                    mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n                }\n                case 2 {\n                    mstore(sub(resultPtr, 1), shl(248, 0x3d))\n                }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC1155.sol\";\nimport \"./interfaces/IERC1155TokenReceiver.sol\";\nimport \"./libraries/BoringAddress.sol\";\n\n// Written by OreNoMochi (https://github.com/OreNoMochii), BoringCrypto\n\ncontract ERC1155 is IERC1155 {\n    using BoringAddress for address;\n\n    // mappings\n    mapping(address => mapping(address => bool)) public override isApprovedForAll; // map of operator approval\n    mapping(address => mapping(uint256 => uint256)) public override balanceOf; // map of tokens owned by\n    mapping(uint256 => uint256) public totalSupply; // totalSupply per token\n\n    function supportsInterface(bytes4 interfaceID) public pure override virtual returns (bool) {\n        return\n            interfaceID == this.supportsInterface.selector || // EIP-165\n            interfaceID == 0xd9b67a26 || // ERC-1155\n            interfaceID == 0x0e89341c; // EIP-1155 Metadata\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view override returns (uint256[] memory balances) {\n        uint256 len = owners.length;\n        require(len == ids.length, \"ERC1155: Length mismatch\");\n\n        balances = new uint256[](len);\n\n        for (uint256 i = 0; i < len; i++) {\n            balances[i] = balanceOf[owners[i]][ids[i]];\n        }\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 value\n    ) internal {\n        require(to != address(0), \"No 0 address\");\n\n        balanceOf[to][id] += value;\n        totalSupply[id] += value;\n\n        emit TransferSingle(msg.sender, address(0), to, id, value);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 value\n    ) internal {\n        require(from != address(0), \"No 0 address\");\n\n        balanceOf[from][id] -= value;\n        totalSupply[id] -= value;\n\n        emit TransferSingle(msg.sender, from, address(0), id, value);\n    }\n\n    function _transferSingle(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) internal {\n        require(to != address(0), \"No 0 address\");\n\n        balanceOf[from][id] -= value;\n        balanceOf[to][id] += value;\n\n        emit TransferSingle(msg.sender, from, to, id, value);\n    }\n\n    function _transferBatch(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) internal {\n        require(to != address(0), \"No 0 address\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n            balanceOf[from][id] -= value;\n            balanceOf[to][id] += value;\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, values);\n    }\n\n    function _requireTransferAllowed(address from) internal view virtual {\n        require(from == msg.sender || isApprovedForAll[from][msg.sender] == true, \"Transfer not allowed\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override {\n        _requireTransferAllowed(from);\n\n        _transferSingle(from, to, id, value);\n\n        if (to.isContract()) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, value, data) ==\n                    bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override {\n        require(ids.length == values.length, \"ERC1155: Length mismatch\");\n        _requireTransferAllowed(from);\n\n        _transferBatch(from, to, ids, values);\n\n        if (to.isContract()) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, values, data) ==\n                    bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function setApprovalForAll(address operator, bool approved) external virtual override {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function uri(\n        uint256 /*assetId*/\n    ) external view virtual returns (string memory) {\n        return \"\";\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./IERC165.sol\";\n\ninterface IERC1155 is IERC165 {\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event URI(string _value, uint256 indexed _id);\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 50000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}